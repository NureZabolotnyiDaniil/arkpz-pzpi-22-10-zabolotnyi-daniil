Харківський національний університет радіоелектроніки

Кафедра програмної інженерії






Звіт
З Практичної роботи № 2.
«Методи рефакторингу коду програмного забезпечення»
з дисципліни «Аналіз та Рефакторинг коду» 







Виконав:                ст. гр. ПЗПІ 22-10  Заболотний Д.М.		Перевірив:
Сокорчук І. П.






Харків 2024
Мета:
Навчитись основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.

Метод Extract Variable
Суть методу:
Присвоєння складних або повторюваних фрагментів коду (виразів, параметрів) тимчасовим змінним зі зрозумілими іменами для покращення читабельності та усунення дублювання.
Основні проблеми:
-	Дублювання виразів: Повторне звернення до вкладених властивостей (наприклад, callback_query.message.chat.id) веде до дублювання коду.
-	Низька читабельність: Вкладені вирази без пояснювальних змінних ускладнюють розуміння коду.
-	Ускладнення підтримки: При зміні структури об’єкта потрібно виправляти багато однакових виразів у різних місцях.
На рисунку 1 наведено приклад коду до рефакторингу. В даному коді ми можемо побачити:і
-	Дублювання параметрів: callback_query.from_user.id повторюється 5 разів, callback_query.message.chat.id — 4 рази.
-	Складну читабельність: Код доволі великий та такі довгі вирази заважають зрозуміти логіку (наприклад, не завжди зрозуміло, що callback_query.from_user.id це саме user_id).
-	Ризик помилок: При зміні структури callback_query потрібно робити правки в багатьох місцях.

 
Рисунок 1 - Extract Variable. Приклад коду до рефакторингу.

Після змін, можна виділити:
-	Значення chat_id, user_id та message_id винесені у власні змінні, що спрощує розуміння логіки функції.
-	Зменшилась кількість повторюваних виразів, що знижує шанс помилки при їх використанні.
-	Код виглядає більш акуратно і чітко передає, які параметри використовуються у викликах інших функцій.
 
Рисунок 2 - Extract Variable. Код після рефакторингу.

Метод Replace Error Code with Exception
Суть методу: Заміна спеціальних кодів помилок (-1, null, false) на механізм винятків (exceptions).
Основні проблеми це:
-	Коди помилок часто призводять до нагромадження умовних перевірок (if-else), що ускладнює читання коду.
-	Також, код менш структурований, оскільки немає розділу логіки роботи основного сценарію коду та обробки помилок
-	Помилкове або забуте оброблення коду помилки може призвести до небажаних наслідків.
На рисунку 3 наведено приклад коду до рефакторингу. В цьому прикладі:
-	Метод withdraw повертає -1 при недостатньому балансі, що змушує викликаючий код перевіряти це значення.
-	Код, який викликає withdraw, повинен містити додаткову логіку перевірки результату, що ускладнює основний потік виконання.
-	Повернення числових кодів не дає зрозуміти, яка саме помилка сталася, і не дозволяє використати стандартні механізми обробки винятків.
 
Рисунок 3 - Replace Error Code with Exception. Приклад коду до рефакторингу.

Після рефакторингу отримаємо код, наведений на рисунку 4. В даному випадку:
-	Метод withdraw тепер не повертає код помилки, а генерує виняток, що покращує логіку обробки ситуацій з недостатнім балансом.
-	Викликаючий код використовує блок try/except для обробки винятків, що знижує ризик пропуску обробки помилки.
-	Повідомлення про помилку містить детальну інформацію, що полегшує налагодження та розуміння проблем.
 
Рисунок 4 - Replace Error Code with Exception. Код після рефакторингу.

Метод Introduce Null Object
Суть методу полягає в створенні спеціального об’єкта з нейтральною поведінкою замість використання null.
Основні проблеми це:
-	Розповсюджені перевірки на None у коді роблять логіку заплутаною і повторюваною.
-	Використання None може призвести до помилок типу NullReference, якщо перевірка випадково пропущена.
-	Обробка відсутніх даних розкидана по коду, що ускладнює підтримку.
На рисунку 5 наведено приклад коду до рефакторингу. В прикладі можна побачити:
-	Функція create_order повертає значення, яке потім перевіряється на None, що призводить до додаткових умовних операторів.
-	Якщо створення замовлення не вдалося (order_id is None), обробка помилки розташована безпосередньо у функції order_creation, що ускладнює її читання та підтримку.
-	Різні сценарії обробки (успішне та неуспішне створення замовлення) не мають спільного інтерфейсу, що призводить до дублювання коду.
 
Рисунок 5 - Introduce Null Object. Приклад коду до рефакторингу.

За допомогою застосування методу Introduce Null Object ми отримуємо код, наведений на рисунку 6.
-	Тепер Основний код викликає метод handle_creation_result незалежно від того, чи є замовлення успішним або ні, не турбуючись про перевірку на None.
-	Логіка обробки неуспішного створення замовлення переміщена в клас NullOrder, що зменшує складність функції order_creation.
-	Якщо з’являться нові варіанти обробки помилок, їх можна буде реалізувати через нові класи-нащадки, не змінюючи основну логіку.

 
Рисунок 6 - Introduce Null Object. Код після рефакторингу.

Висновокі
За результатами застосування методів рефакторингу, зокрема Extract Variable, Replace Error Code with Exception та Introduce Null Object, можна зробити наступні висновки:
При застосуванні Extract Variable. Винесення повторюваних виразів у змінні покращило структуру та читабельність коду, зменшивши дублювання і ризик помилок.
При застосуванні Replace Error Code with Exception. Використання винятків замість кодів помилок чітко розділило основну логіку та обробку помилок, що зробило код більш надійним і зрозумілим.
При застосуванні Introduce Null Object. Заміна None на спеціальний об’єкт усунула численні перевірки на відсутність значень, спростивши логіку обробки помилкових ситуацій.
Таким чином, застосування цих методів суттєво покращило якість коду, зробивши його чистішим, підтримуваним і легким для розширення.

Відео презентація: https://youtu.be/JOv_Liggx1Q

Додаток А
